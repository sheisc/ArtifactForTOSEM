/*
   american fuzzy lop - wrapper for GNU as
   ---------------------------------------

   Written and maintained by Michal Zalewski <lcamtuf@google.com>

   Copyright 2013, 2014, 2015 Google Inc. All rights reserved.

   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at:

     http://www.apache.org/licenses/LICENSE-2.0

   The sole purpose of this wrapper is to preprocess assembly files generated
   by GCC / clang and inject the instrumentation bits included from afl-as.h. It
   is automatically invoked by the toolchain when compiling programs using
   afl-gcc / afl-clang.

   Note that it's an explicit non-goal to instrument hand-written assembly,
   be it in separate .s files or in __asm__ blocks. The only aspiration this
   utility has right now is to be able to skip them gracefully and allow the
   compilation process to continue.

   That said, see experimental/clang_asm_normalize/ for a solution that may
   allow clang users to make things work even with hand-crafted assembly. Just
   note that there is no equivalent for GCC.

 */

#define AFL_MAIN

#include "config.h"
#include "types.h"
#include "debug.h"
#include "alloc-inl.h"

#include "afl-as.h"

#include <stdio.h>
#include <unistd.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>
#include <ctype.h>
#include <fcntl.h>
// PAGE_SIZE
#include <sys/user.h>
#include <sys/wait.h>
#include <sys/time.h>

#include "spa.h"



static u8** as_params;          /* Parameters passed to the real 'as'   */

static u8*  input_file;         /* Originally specified input file      */
static u8*  modified_file;      /* Instrumented file for the real 'as'  */

static u8   be_quiet,           /* Quiet mode (no stderr output)        */
            clang_mode,         /* Running in clang mode?               */
            pass_thru,          /* Just pass data through?              */
            just_version,       /* Just show version?                   */
            sanitizer;          /* Using ASAN / MSAN                    */

static u32  inst_ratio = 100,   /* Instrumentation probability (%)      */
            as_par_cnt = 1;     /* Number of params to 'as'             */

/* If we don't find --32 or --64 in the command line, default to
   instrumentation for whichever mode we were compiled with. This is not
   perfect, but should do the trick for almost all use cases. */

#ifdef __x86_64__

static u8   use_64bit = 1;

#else

static u8   use_64bit = 0;

#ifdef __APPLE__
#  error "Sorry, 32-bit Apple platforms are not supported."
#endif /* __APPLE__ */

#endif /* ^__x86_64__ */


// further check whether it is a pass_thru, for fixing up rustc-generated assembly code
static int spa_is_rustc_pass_thru(u8 * fpath){
    static u8 tmp_line[MAX_LINE];
    int n_s = 0, n_e = 0; // start, end
    if(fpath){
        FILE *f = fopen(fpath, "r");

        if (!f) PFATAL("Unable to read '%s'", fpath);
        while (fgets(tmp_line, MAX_LINE, f)) {
            if(!strncmp(tmp_line, SPA_CFI_STARTPROC, strlen(SPA_CFI_STARTPROC))){
                n_s++;
            }
            else if(!strncmp(tmp_line, SPA_CFI_ENDPROC, strlen(SPA_CFI_ENDPROC))){
                n_e++;
            }
        }
        fclose(f);
    }
    return n_s > 0 && n_s == n_e;

}

/* Examine and modify parameters to pass to 'as'. Note that the file name
   is always the last parameter passed by GCC, so we exploit this property
   to keep the code simple. */

static void edit_params(int argc, char** argv) {

  u8 *tmp_dir = getenv("TMPDIR"), *afl_as = getenv("AFL_AS");
  u32 i;

#ifdef __APPLE__

  u8 use_clang_as = 0;

  /* On MacOS X, the Xcode cctool 'as' driver is a bit stale and does not work
     with the code generated by newer versions of clang that are hand-built
     by the user. See the thread here: http://goo.gl/HBWDtn.

     To work around this, when using clang and running without AFL_AS
     specified, we will actually call 'clang -c' instead of 'as -q' to
     compile the assembly file.

     The tools aren't cmdline-compatible, but at least for now, we can
     seemingly get away with this by making only very minor tweaks. Thanks
     to Nico Weber for the idea. */

  if (clang_mode && !afl_as) {

    use_clang_as = 1;

    afl_as = getenv("AFL_CC");
    if (!afl_as) afl_as = getenv("AFL_CXX");
    if (!afl_as) afl_as = "clang";

  }

#endif /* __APPLE__ */

  /* Although this is not documented, GCC also uses TEMP and TMP when TMPDIR
     is not set. We need to check these non-standard variables to properly
     handle the pass_thru logic later on. */

  if (!tmp_dir) tmp_dir = getenv("TEMP");
  if (!tmp_dir) tmp_dir = getenv("TMP");
  if (!tmp_dir) tmp_dir = "/tmp";

  as_params = ck_alloc((argc + 32) * sizeof(u8*));

  //as_params[0] = afl_as ? afl_as : (u8*)"as";
  as_params[0] = afl_as ? afl_as : (u8*)"/usr/bin/as";

  as_params[argc] = 0;

  for (i = 1; i < argc - 1; i++) {
    //printf("argv[%d] = %s\n", i, argv[i]);
    if (!strcmp(argv[i], "--64")) use_64bit = 1;
    else if (!strcmp(argv[i], "--32")) use_64bit = 0;

#ifdef __APPLE__

    /* The Apple case is a bit different... */

    if (!strcmp(argv[i], "-arch") && i + 1 < argc) {

      if (!strcmp(argv[i + 1], "x86_64")) use_64bit = 1;
      else if (!strcmp(argv[i + 1], "i386"))
        FATAL("Sorry, 32-bit Apple platforms are not supported.");

    }

    /* Strip options that set the preference for a particular upstream
       assembler in Xcode. */

    if (clang_mode && (!strcmp(argv[i], "-q") || !strcmp(argv[i], "-Q")))
      continue;

#endif /* __APPLE__ */

    as_params[as_par_cnt++] = argv[i];

  }

#ifdef __APPLE__

  /* When calling clang as the upstream assembler, append -c -x assembler
     and hope for the best. */

  if (use_clang_as) {

    as_params[as_par_cnt++] = "-c";
    as_params[as_par_cnt++] = "-x";
    as_params[as_par_cnt++] = "assembler";

  }

#endif /* __APPLE__ */

  input_file = argv[argc - 1];
  //printf("argv[%d] = %s\n", argc - 1, input_file);
  if (input_file[0] == '-') {

    if (!strcmp(input_file + 1, "-version")) {
      just_version = 1;
      modified_file = input_file;
      goto wrap_things_up;
    }

    if (input_file[1]) FATAL("Incorrect use (not called through afl-gcc?)");
      else input_file = NULL;

  } else {

    /* Check if this looks like a standard invocation as a part of an attempt
       to compile a program, rather than using gcc on an ad-hoc .s file in
       a format we may not understand. This works around an issue compiling
       NSS. */

    if (strncmp(input_file, tmp_dir, strlen(tmp_dir)) &&
        strncmp(input_file, "/var/tmp/", 9) &&
        strncmp(input_file, "/tmp/", 5)) pass_thru = 1;

  }
#if 1 // added by iron
  if(spa_is_rustc_pass_thru(input_file)){
      pass_thru = 0;
  }
  //
  {
      s32 _len = strlen(input_file);
      u8 * _dotname = ck_alloc(_len + 1);
      strncpy(_dotname, input_file, _len);
      for(i = 0; i < _len; i++){
          if(_dotname[i] == '\\' || _dotname[i] == '/'){
              _dotname[i] = '.';
          }
      }
      modified_file = alloc_printf("%s/SPA-%u-%u-###%s###.s", tmp_dir, getpid(),
                                   (u32)time(NULL), _dotname);
  }
#endif
//  modified_file = alloc_printf("%s/.afl-%u-%u.s", tmp_dir, getpid(),
//                               (u32)time(NULL));

wrap_things_up:

  as_params[as_par_cnt++] = modified_file;
  as_params[as_par_cnt]   = NULL;

}


/* Process input file, generate modified_file. Insert instrumentation in all
   the appropriate places. */

static void add_instrumentation(void) {

  static u8 line[MAX_LINE];

  FILE* inf;
  FILE* outf;
  s32 outfd;
  u32 ins_lines = 0, n_start = 0, n_end = 0;

  u8  instr_ok = 0, skip_csect = 0, skip_next_label = 0, in_main = 0, is_main_exe = 0,
      skip_intel = 0, skip_app = 0, instrument_next = 0, start2end = 0;

#ifdef __APPLE__

  u8* colon_pos;

#endif /* __APPLE__ */

  if (input_file) {

    inf = fopen(input_file, "r");
    if (!inf) PFATAL("Unable to read '%s'", input_file);

  } else inf = stdin;

  outfd = open(modified_file, O_WRONLY | O_EXCL | O_CREAT, 0600);

  if (outfd < 0) PFATAL("Unable to write to '%s'", modified_file);

  outf = fdopen(outfd, "w");

  if (!outf) PFATAL("fdopen() failed");

  while (fgets(line, MAX_LINE, inf)) {
#if 1   // added by iron.
    /*
       https://www.felixcloutier.com/x86/divps
       When building Firefox-79 by SPA,  LLVM 10
       "/tmp/skcms-7d2933.s", Error: unknown vector operation: ` {z}'
       It is OK for clang, but not for /usr/bin/as:
          vdivps	%zmm10, %zmm0, %zmm0 {%k1} {z}
       So we change it into
           vdivps	%zmm10, %zmm0, %zmm0 {%k1}{z}
       to make both of them happy.

       SPA + LLVM 7
       /tmp/.SPA-1793-1599755391-###.tmp.skcms-1ba473.s###.s
       vmovdqu16	%zmm5, %zmm5 {%k1} {z}
     */
//    if(!strncmp(line, "\tvdivps", 7)){
//        // FIXME: \r\n
//        u8 *ptr = strstr(line, " {z}\n");
//        if(!ptr){
//            ptr = strstr(line, " {z}\r\n");
//        }
//        if(ptr){
//            strcpy(ptr, "{z}\n");
//        }
//    }
      u8 *write_mask_str;
      if((write_mask_str = strstr(line, SPA_XMM_YMM_ZMM_WRITE_MASK_CLANG)) != NULL){
          // FIXME: \r\n
          // We are sure there is enough space here.
          strcpy(write_mask_str, SPA_XMM_YMM_ZMM_WRITE_MAST_GCC);
      }

#endif

    /* In some cases, we want to defer writing the instrumentation trampoline
       until after all the labels, macros, comments, etc. If we're in this
       mode, and if the line starts with a tab followed by a character, dump
       the trampoline now. */

    if (!pass_thru && !skip_intel && !skip_app && !skip_csect && instr_ok &&
        instrument_next && line[0] == '\t' && isalpha(line[1])) {

//      fprintf(outf, use_64bit ? trampoline_fmt_64 : trampoline_fmt_32,
//              R(MAP_SIZE));
      fprintf(outf, use_64bit ? "###SPA## trampoline_fmt_64\n" : "###SPA## trampoline_fmt_32\n");
      if(in_main && !pass_thru && use_64bit){
          fprintf(outf, "###SPA### the entry of main().\n");
#if 0

//#if defined(USE_SPA_BUDDY_STACK_TLS_WITH_STK_SIZE)
//          // Set a flag to notify others that main() has been called.
//          char *reg_x = "%r11";
//          fprintf(outf, "\tmovq\t" ".BUDDY.CALL_STACK_SIZE_MASK@GOTPCREL(%%rip), %s\n", reg_x);
//          fprintf(outf, "\tmovq\t" "$%d, %d(%s)\n", SPA_MAIN_FUNC_CALLED_FLAG,
//                  SPA_OFFSET_OF_MAIN_FUNC_CALLED_FLAG, reg_x);
//#if 0
//          // Get a callee-saved register, such that it is not changed after mprotect().
//          // (1) save the registers
//          fprintf(outf, "\tpushq\t" "%%rdi\n");
//          fprintf(outf, "\tpushq\t" "%%rsi\n");
//          fprintf(outf, "\tpushq\t" "%%rdx\n");


//          // (2) mprotect(addr, 4096, PROT_WRITE | PROT_READ);
//          fprintf(outf, "\tmovq\t" "$3, %%rdx\n");
//          // 4096, one page
//          fprintf(outf, "\tmovq\t" "$4096, %%rsi\n");
//          // the page-aligned address
//          fprintf(outf, "\tmovq\t" ".BUDDY.CALL_STACK_SIZE_MASK@GOTPCREL(%%rip), %%rdi\n");
//          fprintf(outf, "\tcallq\t" "mprotect@PLT\n");

//          // (3) update
//          fprintf(outf, "\tmovq\t" ".BUDDY.CALL_STACK_SIZE_MASK@GOTPCREL(%%rip), %%rdi\n");
//          fprintf(outf, "\tmovq\t" "$%d, %d(%%rdi)\n", SPA_MAIN_FUNC_CALLED_FLAG,
//                  SPA_OFFSET_OF_MAIN_FUNC_CALLED_FLAG);

//          // (4) mprotect(addr, 4096, PROT_READ);
//          fprintf(outf, "\tmovq\t" "$1, %%rdx\n");
//          // 4096, one page
//          fprintf(outf, "\tmovq\t" "$4096, %%rsi\n");
//          fprintf(outf, "\tcallq\t" "mprotect@PLT\n");

//          // (5) restore the registers
//          fprintf(outf, "\tpopq\t" "%%rdx\n");
//          fprintf(outf, "\tpopq\t" "%%rsi\n");
//          fprintf(outf, "\tpopq\t" "%%rdi\n");
//#endif

//#endif

#endif
      }
      instrument_next = 0;
      ins_lines++;

    }

    // The begin of a function
    if(!strncmp(line, SPA_CFI_STARTPROC, strlen(SPA_CFI_STARTPROC))){
        start2end = 1;
        n_start++;
        if(!pass_thru && use_64bit){
#if defined(USE_SPA_SHADOW_STACK)
            fprintf(outf, "%s", line);
            fprintf(outf, "\tpopq\t-%ld(%%rsp)\n", (DEF_SPA_SS_OFFSET));
            fprintf(outf, "\tsubq\t$8, %%rsp\n");
            continue;


#elif defined(USE_SPA_SHADOW_STACK_VIA_REG)
            char * reg_name = "%rax";
            fprintf(outf, "%s", line);
            fprintf(outf, "\tmovq\t" "(%%rsp), %s\n", reg_name);
            fprintf(outf, "\tmovq\t" "%s, -%ld(%%rsp)\n", reg_name, (long)(DEF_SPA_SS_OFFSET));
            continue;


#elif defined(USE_SPA_BUDDY_STACK_TLS)
            fprintf(outf, "%s", line);
            char * reg_x = "%r10";

//            char * reg_y = "%r11";
//            fprintf(outf, "###SPA### FUNCTION_ENTRY\n");
//            fprintf(outf, "\tmovq\t" "(%%rsp), %s\n", reg_y);
//            fprintf(outf, "\tmovq\t" "%%rsp, %s\n", reg_x);
//            fprintf(outf, "\tandq\t" "$%ld, %s\n", (long)DEF_BUDDY_CALL_STACK_SIZE_MASK, reg_x);
//            // randomize return address
//            fprintf(outf, "\taddq\t" "-%ld(%s), %s\n", (long)(DEF_BUDDY_FUNCTION_LOCAL_STORAGE_SIZE), reg_x, reg_y);
//            // Save it on the shadow stack
//            fprintf(outf, "\tmovq\t" "%s, -%ld(%%rsp)\n", reg_y, (long)(DEF_SPA_SS_OFFSET));

            fprintf(outf, "###SPA### FUNCTION_ENTRY\n");
            // Get the random value from TLS
            fprintf(outf, "\tmovq\t" "%%rsp, %s\n", reg_x);
            fprintf(outf, "\tandq\t" "$%ld, %s\n", (long)DEF_BUDDY_CALL_STACK_SIZE_MASK, reg_x);
            fprintf(outf, "\tmovq\t" "-%ld(%s), %s\n", (long)(DEF_BUDDY_FUNCTION_LOCAL_STORAGE_SIZE), reg_x, reg_x);
            // randomize return address
            fprintf(outf, "\taddq\t" "(%%rsp), %s\n", reg_x);
            // Save it on the shadow stack
            fprintf(outf, "\tmovq\t" "%s, -%ld(%%rsp)\n", reg_x, (long)(DEF_SPA_SS_OFFSET));

            continue;


#elif defined(USE_SPA_BUDDY_STACK_TLS_WITH_STK_SIZE)
            fprintf(outf, "%s", line);
            char *reg_x = "%r11";
            char *reg_y = "%r10";
            fprintf(outf, "###SPA### FUNCTION_ENTRY\n");

            // reg_x = rsp
            fprintf(outf, "\tmovq\t" "%%rsp, %s\n", reg_x);
#if defined(NON_PIE_GLOBAL_VAR_FOR_STK_SIZE)
            // reg_y = BUDDY_CALL_STACK_SIZE_MASK
            fprintf(outf, "\tmovq\t" ".BUDDY.CALL_STACK_SIZE_MASK, %s\n", reg_y);
#else
            // reg_y = BUDDY_CALL_STACK_SIZE_MASK
            fprintf(outf, "\tmovq\t" ".BUDDY.CALL_STACK_SIZE_MASK@GOTPCREL(%%rip), %s\n", reg_y);
            fprintf(outf, "\tmovq\t" "(%s), %s\n", reg_y, reg_y);
#endif
            // reg_x &= BUDDY_CALL_STACK_SIZE_MASK
            fprintf(outf, "\tandq\t" "%s, %s\n", reg_y, reg_x);
            // rand_val =
            fprintf(outf, "\tmovq\t" "(%s, %s, 2), %s\n", reg_x, reg_y, reg_x);
            // randomize return address
            fprintf(outf, "\taddq\t" "(%%rsp), %s\n", reg_x);
            // Save it on the shadow stack
            fprintf(outf, "\tmovq\t" "%s, (%%rsp, %s, 1)\n", reg_x, reg_y);

            continue;


#else       // SE_SPA_SHADOW_STACK_PLUS_GLOBAL_RANDVAR
            fprintf(outf, "%s", line);
            char * reg_name = "%rax";
            // USE movq here.
            fprintf(outf, "\tmovq\t" "%s, %s\n", SPA_RANDOM_VAL, reg_name);
            fprintf(outf, "\taddq\t" "(%%rsp), %s\n", reg_name);
            fprintf(outf, "\tmovq\t" "%s, -%ld(%%rsp)\n", reg_name, (long)(DEF_SPA_SS_OFFSET));
            continue;
#endif

        }
    }

    // The end of a function
    if(!strncmp(line, SPA_CFI_ENDPROC, strlen(SPA_CFI_ENDPROC))){
        start2end = 0;
        n_end++;
        if(!pass_thru){
            fprintf(outf, "%s", line);
            continue;
        }
    }
    //if(!pass_thru && !skip_intel && !skip_app && !skip_csect && instr_ok && use_64bit && start2end){ // ignore 32 bit now
    if(!pass_thru && !skip_intel && !skip_app && use_64bit && start2end){ // ignore 32 bit now

        if(!strncmp(line, SPA_GCC_RET, strlen(SPA_GCC_RET))
                || !strncmp(line, SPA_CLANG_RETQ, strlen(SPA_CLANG_RETQ))){

          //if(!strncmp(line, SPA_CLANG_RETQ, strlen(SPA_CLANG_RETQ))){
#if defined(USE_SPA_SHADOW_STACK)
            fprintf(outf, "\taddq\t$8, %%rsp\n");
            fprintf(outf, "\tmovq\t-%ld(%%rsp), %%r11\n", (DEF_SPA_SS_OFFSET));
            fprintf(outf, "\tjmpq\t*%%r11\n");
            continue;


#elif defined(USE_SPA_SHADOW_STACK_VIA_REG)
            fprintf(outf, "\tmovq\t-%ld(%%rsp), %%r11\n", (DEF_SPA_SS_OFFSET));
            fprintf(outf, "\taddq\t$8, %%rsp\n");
            fprintf(outf, "\tjmpq\t*%%r11\n");
            continue;


#elif defined(USE_SPA_BUDDY_STACK_TLS)
            char * reg_x = "%r11";
            char * reg_y = "%r10";
            fprintf(outf, "###SPA### FUNCTION_EXIT\n");
            // Load the random value and do de-randomization
            fprintf(outf, "\tmovq\t" "%%rsp, %s\n", reg_y);
            fprintf(outf, "\tandq\t" "$%ld, %s\n", DEF_BUDDY_CALL_STACK_SIZE_MASK, reg_y);
            // Load randomized ret addr
            fprintf(outf, "\tmovq\t" "-%ld(%%rsp), %s\n", (long)(DEF_SPA_SS_OFFSET), reg_x);
            // de-randomization
            fprintf(outf, "\tsubq\t" "-%ld(%s), %s\n", (long)(DEF_BUDDY_FUNCTION_LOCAL_STORAGE_SIZE), reg_y, reg_x);
            // adjust call stack pointer
            fprintf(outf, "\taddq\t" "$%ld, %%rsp\n", (long)(SPA_CPU_WORD_LENGTH));
            // jump to call-site
            fprintf(outf, "\tjmp\t"  "*%s\n", reg_x);
            continue;


#elif defined(USE_SPA_BUDDY_STACK_TLS_WITH_STK_SIZE)
            char *reg_x = "%r11";
            char *reg_y = "%r10";
            fprintf(outf, "###SPA### FUNCTION_EXIT\n");
            // reg_x = rsp
            fprintf(outf, "\tmovq\t" "%%rsp, %s\n", reg_x);
#if defined(NON_PIE_GLOBAL_VAR_FOR_STK_SIZE)
            // reg_y = BUDDY_CALL_STACK_SIZE_MASK
            fprintf(outf, "\tmovq\t" ".BUDDY.CALL_STACK_SIZE_MASK, %s\n", reg_y);
#else
            // reg_y = BUDDY_CALL_STACK_SIZE_MASK
            fprintf(outf, "\tmovq\t" ".BUDDY.CALL_STACK_SIZE_MASK@GOTPCREL(%%rip), %s\n", reg_y);
            fprintf(outf, "\tmovq\t" "(%s), %s\n", reg_y, reg_y);
#endif
            // reg_x &= CALL_STACK_SIZE_MASK
            fprintf(outf, "\tandq\t" "%s, %s\n", reg_y, reg_x);
            // reg_x = rand_val
            fprintf(outf, "\tmovq\t" "(%s, %s, 2), %s\n", reg_x, reg_y, reg_x);
            // reg_y = saved return address
            fprintf(outf, "\tmovq\t" "(%%rsp, %s, 1), %s\n", reg_y, reg_y);
            fprintf(outf, "\tsubq\t" "%s, %s\n", reg_x, reg_y);
            // adjust call stack pointer
            fprintf(outf, "\taddq\t" "$%ld, %%rsp\n", (long)(SPA_CPU_WORD_LENGTH));
            // jump to call-site
            fprintf(outf, "\tjmp\t"  "*%s\n", reg_y);
            continue;


#else       // SE_SPA_SHADOW_STACK_PLUS_GLOBAL_RANDVAR
            char * reg_name = "%r11";
            //
            fprintf(outf, "\tmovq\t" "-%ld(%%rsp), %s\n", (long)(DEF_SPA_SS_OFFSET), reg_name);
            fprintf(outf, "\tsubq\t" "%s, %s\n", SPA_RANDOM_VAL, reg_name);
            fprintf(outf, "\taddq\t" "$%ld, %%rsp\n", (long)(SPA_CPU_WORD_LENGTH));
            fprintf(outf, "\tjmp\t"  "*%s\n", reg_name);
            continue;
#endif
        }
    }

    /* Output the actual line, call it a day in pass-thru mode. */

    fputs(line, outf);

    if (pass_thru) continue;

    /* All right, this is where the actual fun begins. For one, we only want to
       instrument the .text section. So, let's keep track of that in processed
       files - and let's set instr_ok accordingly. */

    if (line[0] == '\t' && line[1] == '.') {

      /* OpenBSD puts jump tables directly inline with the code, which is
         a bit annoying. They use a specific format of p2align directives
         around them, so we use that as a signal. */

      if (!clang_mode && instr_ok && !strncmp(line + 2, "p2align ", 8) &&
          isdigit(line[10]) && line[11] == '\n') skip_next_label = 1;

      if (!strncmp(line + 2, "text\n", 5) ||
          !strncmp(line + 2, "section\t.text", 13) ||
          !strncmp(line + 2, "section\t__TEXT,__text", 21) ||
          !strncmp(line + 2, "section __TEXT,__text", 21)) {
        instr_ok = 1;
        continue;
      }

      if (!strncmp(line + 2, "section\t", 8) ||
          !strncmp(line + 2, "section ", 8) ||
          !strncmp(line + 2, "bss\n", 4) ||
          !strncmp(line + 2, "data\n", 5)) {
        instr_ok = 0;
        continue;
      }

    }

    /* Detect off-flavor assembly (rare, happens in gdb). When this is
       encountered, we set skip_csect until the opposite directive is
       seen, and we do not instrument. */

    if (strstr(line, ".code")) {

      if (strstr(line, ".code32")) skip_csect = use_64bit;
      if (strstr(line, ".code64")) skip_csect = !use_64bit;

    }

    /* Detect syntax changes, as could happen with hand-written assembly.
       Skip Intel blocks, resume instrumentation when back to AT&T. */

    if (strstr(line, ".intel_syntax")) skip_intel = 1;
    if (strstr(line, ".att_syntax")) skip_intel = 0;

    /* Detect and skip ad-hoc __asm__ blocks, likewise skipping them. */

    if (line[0] == '#' || line[1] == '#') {

      if (strstr(line, "#APP")) skip_app = 1;
      if (strstr(line, "#NO_APP")) skip_app = 0;

    }

    /* If we're in the right mood for instrumenting, check for function
       names or conditional labels. This is a bit messy, but in essence,
       we want to catch:

         ^main:      - function entry point (always instrumented)
         ^.L0:       - GCC branch label
         ^.LBB0_0:   - clang branch label (but only in clang mode)
         ^\tjnz foo  - conditional branches

       ...but not:

         ^# BB#0:    - clang comments
         ^ # BB#0:   - ditto
         ^.Ltmp0:    - clang non-branch labels
         ^.LC0       - GCC non-branch labels
         ^.LBB0_0:   - ditto (when in GCC mode)
         ^\tjmp foo  - non-conditional jumps

       Additionally, clang and GCC on MacOS X follow a different convention
       with no leading dots on labels, hence the weird maze of #ifdefs
       later on.

     */

    if (skip_intel || skip_app || skip_csect || !instr_ok ||
        line[0] == '#' || line[0] == ' ') continue;

    /* Conditional branch instruction (jnz, etc). We append the instrumentation
       right after the branch (to instrument the not-taken path) and at the
       branch destination label (handled later on). */

    if (line[0] == '\t') {

      if (line[1] == 'j' && line[2] != 'm' && R(100) < inst_ratio) {

//        fprintf(outf, use_64bit ? trampoline_fmt_64 : trampoline_fmt_32,
//                R(MAP_SIZE));
        fprintf(outf, use_64bit ? "###SPA### trampoline_fmt_64\n" : "###SPA### trampoline_fmt_32\n");
        ins_lines++;

      }

      continue;

    }

    /* Label of some sort. This may be a branch destination, but we need to
       tread carefully and account for several different formatting
       conventions. */

#ifdef __APPLE__

    /* Apple: L<whatever><digit>: */

    if ((colon_pos = strstr(line, ":"))) {

      if (line[0] == 'L' && isdigit(*(colon_pos - 1))) {

#else

    /* Everybody else: .L<whatever>: */

    if (strstr(line, ":")) {

      if (line[0] == '.') {

#endif /* __APPLE__ */

        /* .L0: or LBB0_0: style jump destination */

#ifdef __APPLE__

        /* Apple: L<num> / LBB<num> */

        if ((isdigit(line[1]) || (clang_mode && !strncmp(line, "LBB", 3)))
            && R(100) < inst_ratio) {

#else

        /* Apple: .L<num> / .LBB<num> */

        if ((isdigit(line[2]) || (clang_mode && !strncmp(line + 1, "LBB", 3)))
            && R(100) < inst_ratio) {

#endif /* __APPLE__ */

          /* An optimization is possible here by adding the code only if the
             label is mentioned in the code in contexts other than call / jmp.
             That said, this complicates the code by requiring two-pass
             processing (messy with stdin), and results in a speed gain
             typically under 10%, because compilers are generally pretty good
             about not generating spurious intra-function jumps.

             We use deferred output chiefly to avoid disrupting
             .Lfunc_begin0-style exception handling calculations (a problem on
             MacOS X). */

          if (!skip_next_label) instrument_next = 1; else skip_next_label = 0;

        }

      } else {

        /* Function label (always instrumented, deferred mode). */

        instrument_next = 1;

        // added by iron, 2020.09.01
        if(!strncmp(line, "main:", 5) && !start2end){
            in_main = 1;
            is_main_exe = 1;
        }else{
            in_main = 0;
        }
      }

    }

  }

  if(is_main_exe){
      fprintf(outf, "###SPA### this module contains main().\n");
      SAYF("###SPA###  %s contains main().\n", input_file);
#if defined(USE_SPA_SHADOW_STACK_PLUS_GLOBAL_RANDVAR)
        if(!pass_thru){
            /*
          .type .unsw.randomval,@object         # @bssData
              .globl  .unsw.randomval
              .bss
              .p2align  12
          .unsw.randomval:
              .zero PAGE_SIZE
              .size .unsw.randomval, PAGE_SIZE
           */

            fprintf(outf, "\n\t.type\t.unsw.randomval, @object\n");
            fprintf(outf, "\t.globl\t.unsw.randomval\n");
            fprintf(outf, "\t.bss\n");
            fprintf(outf, "\t.p2align\t12\n");
            fprintf(outf, ".unsw.randomval:\n");
            fprintf(outf, "\t.zero\t%u\n", (u32) PAGE_SIZE);
            fprintf(outf, "\t.size\t.unsw.randomval, %u\n", (u32) PAGE_SIZE);
        }
#endif
  }

#if 0

//#if defined(USE_SPA_BUDDY_STACK_TLS_WITH_STK_SIZE)
//  if(!pass_thru){ // FIXME: including pass_thru ?

//#if defined(NON_PIE_GLOBAL_VAR_FOR_STK_SIZE)
//    if(is_main_exe){
//#endif
//      /*

//            -------------------------Weak Symbol to make the linker happy ------------------
//            .type	.BUDDY.CALL_STACK_SIZE_MASK,@object # @CALL_STACK_SIZE_MASK
//                .data
//                .weak	.BUDDY.CALL_STACK_SIZE_MASK
//                .p2align	12
//            .BUDDY.CALL_STACK_SIZE_MASK:
//                .quad	-8388608                # 0xffffffffff800000
//                .quad   0x57534E5540455343      # CSE@UNSW
//                .zero   4080
//                .size	.BUDDY.CALL_STACK_SIZE_MASK, 4096
//         */

//      fprintf(outf, "\n\t.type\t.BUDDY.CALL_STACK_SIZE_MASK, @object\n");
//      fprintf(outf, "\t.data\n");
////      if(is_main_exe){ // FIXME
////        fprintf(outf, "\t.globl\t.BUDDY.CALL_STACK_SIZE_MASK\n");
////      }else{
////        fprintf(outf, "\t.weak\t.BUDDY.CALL_STACK_SIZE_MASK\n");
////      }
//      fprintf(outf, "\t.weak\t.BUDDY.CALL_STACK_SIZE_MASK\n");
//      fprintf(outf, "\t.p2align\t12\n");
//      fprintf(outf, ".BUDDY.CALL_STACK_SIZE_MASK:\n");
//      fprintf(outf, "\t.quad\t%ld\n", (long) DEF_BUDDY_CALL_STACK_SIZE_MASK);
//      fprintf(outf, "\t.quad\t%ld\n", (long) SPA_GLOBAL_STACK_SIZE_MAGIC_NUM);
//      fprintf(outf, "\t.quad\t%ld\n", (long) SPA_GLOBAL_STACK_SIZE_MAGIC_NUM);
//      fprintf(outf, "\t.quad\t%ld\n", (long) SPA_GLOBAL_STACK_SIZE_MAGIC_NUM);
//      // FIXME: 64-bit word-length hardcoded here
//      fprintf(outf, "\t.zero\t%u\n", (u32) (PAGE_SIZE - 32));
//      fprintf(outf, "\t.size\t.BUDDY.CALL_STACK_SIZE_MASK, %u\n", (u32) PAGE_SIZE);

//#if defined(NON_PIE_GLOBAL_VAR_FOR_STK_SIZE)
//    }
//#endif
//  }
//#endif

#endif
//  if (ins_lines)
//    fputs(use_64bit ? main_payload_64 : main_payload_32, outf);

  if (ins_lines)
    fputs(use_64bit ? "###SPA### main_payload_64\n" : "###SPA### main_payload_32\n", outf);

  fprintf(outf,"###SPA### %s:  cfi_startproc = %d, cfi_endproc = %d, pass_thru = %d \n",
                     input_file, n_start, n_end, pass_thru);

  if (input_file) fclose(inf);
  fclose(outf);


  if (!be_quiet) {
    if(!pass_thru && n_start != n_end){
      FATAL("%s:  the numbers of .cfi_startproc(%d) and .cfi_endproc(%d) are different.\n",
                         input_file, n_start, n_end);
    }
    if (!ins_lines) WARNF("No instrumentation targets found%s.",
                          pass_thru ? " (pass-thru mode)" : "");
    else OKF("Instrumented %u locations (%u-startproc, %u-endproc, %s-bit, %s mode, ratio %u%%).",
             ins_lines, n_start, n_end,  use_64bit ? "64" : "32",
             getenv("AFL_HARDEN") ? "hardened" :
             (sanitizer ? "ASAN/MSAN" : "non-hardened"),
             inst_ratio);

  }

}


/* Main entry point */

int main(int argc, char** argv) {

  s32 pid;
  u32 rand_seed;
  int status;
  u8* inst_ratio_str = getenv("AFL_INST_RATIO");

  struct timeval tv;
  struct timezone tz;

  clang_mode = !!getenv(CLANG_ENV_VAR);

  if (isatty(2) && !getenv("AFL_QUIET")) {

    //SAYF(cCYA "afl-as " cBRI VERSION cRST " by <lcamtuf@google.com>\n");
    SAYF(cCYA "spa-as " cBRI SPA_VERSION cRST "\n");
  } else be_quiet = 1;

  if (argc < 2) {

    SAYF("\n"
         "It is a wrapper around GNU 'as',\n"
         "executed by the toolchain whenever using afl-clang or afl-clang++. \n"
         "You probably don't want to run this program directly.\n\n"
        );

    exit(1);

  }

  gettimeofday(&tv, &tz);

  rand_seed = tv.tv_sec ^ tv.tv_usec ^ getpid();

  srandom(rand_seed);

  edit_params(argc, argv);

  if (inst_ratio_str) {

    if (sscanf(inst_ratio_str, "%u", &inst_ratio) != 1 || inst_ratio > 100)
      FATAL("Bad value of AFL_INST_RATIO (must be between 0 and 100)");

  }

  if (getenv(AS_LOOP_ENV_VAR))
    FATAL("Endless loop when calling 'as' (remove '.' from your PATH)");

  setenv(AS_LOOP_ENV_VAR, "1", 1);

  /* When compiling with ASAN, we don't have a particularly elegant way to skip
     ASAN-specific branches. But we can probabilistically compensate for
     that... */

  if (getenv("AFL_USE_ASAN") || getenv("AFL_USE_MSAN")) {
    sanitizer = 1;
    inst_ratio /= 3;
  }

  if (!just_version) add_instrumentation();

  if (!(pid = fork())) {

    execvp(as_params[0], (char**)as_params);
    FATAL("Oops, failed to execute '%s' - check your PATH", as_params[0]);

  }

  if (pid < 0) PFATAL("fork() failed");

  if (waitpid(pid, &status, 0) <= 0) PFATAL("waitpid() failed");

  if (!getenv("AFL_KEEP_ASSEMBLY")) unlink(modified_file);

  exit(WEXITSTATUS(status));

}
